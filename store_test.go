// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package sessionup

import (
	"context"
	"sync"
)

var (
	lockStoreMockCreate          sync.RWMutex
	lockStoreMockDeleteByToken   sync.RWMutex
	lockStoreMockDeleteByUserKey sync.RWMutex
	lockStoreMockFetchByToken    sync.RWMutex
	lockStoreMockFetchByUserKey  sync.RWMutex
)

// Ensure, that StoreMock does implement Store.
// If this is not the case, regenerate this file with moq.
var _ Store = &StoreMock{}

// StoreMock is a mock implementation of Store.
//
//     func TestSomethingThatUsesStore(t *testing.T) {
//
//         // make and configure a mocked Store
//         mockedStore := &StoreMock{
//             CreateFunc: func(ctx context.Context, ses Session) error {
// 	               panic("mock out the Create method")
//             },
//             DeleteByTokenFunc: func(ctx context.Context, tok string) error {
// 	               panic("mock out the DeleteByToken method")
//             },
//             DeleteByUserKeyFunc: func(ctx context.Context, key string, expTok ...string) error {
// 	               panic("mock out the DeleteByUserKey method")
//             },
//             FetchByTokenFunc: func(ctx context.Context, tok string) (Session, error) {
// 	               panic("mock out the FetchByToken method")
//             },
//             FetchByUserKeyFunc: func(ctx context.Context, key string) ([]Session, error) {
// 	               panic("mock out the FetchByUserKey method")
//             },
//         }
//
//         // use mockedStore in code that requires Store
//         // and then make assertions.
//
//     }
type StoreMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, ses Session) error

	// DeleteByTokenFunc mocks the DeleteByToken method.
	DeleteByTokenFunc func(ctx context.Context, tok string) error

	// DeleteByUserKeyFunc mocks the DeleteByUserKey method.
	DeleteByUserKeyFunc func(ctx context.Context, key string, expTok ...string) error

	// FetchByTokenFunc mocks the FetchByToken method.
	FetchByTokenFunc func(ctx context.Context, tok string) (Session, error)

	// FetchByUserKeyFunc mocks the FetchByUserKey method.
	FetchByUserKeyFunc func(ctx context.Context, key string) ([]Session, error)

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ses is the ses argument value.
			Ses Session
		}
		// DeleteByToken holds details about calls to the DeleteByToken method.
		DeleteByToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tok is the tok argument value.
			Tok string
		}
		// DeleteByUserKey holds details about calls to the DeleteByUserKey method.
		DeleteByUserKey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// ExpTok is the expTok argument value.
			ExpTok []string
		}
		// FetchByToken holds details about calls to the FetchByToken method.
		FetchByToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tok is the tok argument value.
			Tok string
		}
		// FetchByUserKey holds details about calls to the FetchByUserKey method.
		FetchByUserKey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
	}
}

// Create calls CreateFunc.
func (mock *StoreMock) Create(ctx context.Context, ses Session) error {
	if mock.CreateFunc == nil {
		panic("StoreMock.CreateFunc: method is nil but Store.Create was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ses Session
	}{
		Ctx: ctx,
		Ses: ses,
	}
	lockStoreMockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	lockStoreMockCreate.Unlock()
	return mock.CreateFunc(ctx, ses)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//     len(mockedStore.CreateCalls())
func (mock *StoreMock) CreateCalls() []struct {
	Ctx context.Context
	Ses Session
} {
	var calls []struct {
		Ctx context.Context
		Ses Session
	}
	lockStoreMockCreate.RLock()
	calls = mock.calls.Create
	lockStoreMockCreate.RUnlock()
	return calls
}

// DeleteByToken calls DeleteByTokenFunc.
func (mock *StoreMock) DeleteByToken(ctx context.Context, tok string) error {
	if mock.DeleteByTokenFunc == nil {
		panic("StoreMock.DeleteByTokenFunc: method is nil but Store.DeleteByToken was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Tok string
	}{
		Ctx: ctx,
		Tok: tok,
	}
	lockStoreMockDeleteByToken.Lock()
	mock.calls.DeleteByToken = append(mock.calls.DeleteByToken, callInfo)
	lockStoreMockDeleteByToken.Unlock()
	return mock.DeleteByTokenFunc(ctx, tok)
}

// DeleteByTokenCalls gets all the calls that were made to DeleteByToken.
// Check the length with:
//     len(mockedStore.DeleteByTokenCalls())
func (mock *StoreMock) DeleteByTokenCalls() []struct {
	Ctx context.Context
	Tok string
} {
	var calls []struct {
		Ctx context.Context
		Tok string
	}
	lockStoreMockDeleteByToken.RLock()
	calls = mock.calls.DeleteByToken
	lockStoreMockDeleteByToken.RUnlock()
	return calls
}

// DeleteByUserKey calls DeleteByUserKeyFunc.
func (mock *StoreMock) DeleteByUserKey(ctx context.Context, key string, expTok ...string) error {
	if mock.DeleteByUserKeyFunc == nil {
		panic("StoreMock.DeleteByUserKeyFunc: method is nil but Store.DeleteByUserKey was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		ExpTok []string
	}{
		Ctx:    ctx,
		Key:    key,
		ExpTok: expTok,
	}
	lockStoreMockDeleteByUserKey.Lock()
	mock.calls.DeleteByUserKey = append(mock.calls.DeleteByUserKey, callInfo)
	lockStoreMockDeleteByUserKey.Unlock()
	return mock.DeleteByUserKeyFunc(ctx, key, expTok...)
}

// DeleteByUserKeyCalls gets all the calls that were made to DeleteByUserKey.
// Check the length with:
//     len(mockedStore.DeleteByUserKeyCalls())
func (mock *StoreMock) DeleteByUserKeyCalls() []struct {
	Ctx    context.Context
	Key    string
	ExpTok []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		ExpTok []string
	}
	lockStoreMockDeleteByUserKey.RLock()
	calls = mock.calls.DeleteByUserKey
	lockStoreMockDeleteByUserKey.RUnlock()
	return calls
}

// FetchByToken calls FetchByTokenFunc.
func (mock *StoreMock) FetchByToken(ctx context.Context, tok string) (Session, error) {
	if mock.FetchByTokenFunc == nil {
		panic("StoreMock.FetchByTokenFunc: method is nil but Store.FetchByToken was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Tok string
	}{
		Ctx: ctx,
		Tok: tok,
	}
	lockStoreMockFetchByToken.Lock()
	mock.calls.FetchByToken = append(mock.calls.FetchByToken, callInfo)
	lockStoreMockFetchByToken.Unlock()
	return mock.FetchByTokenFunc(ctx, tok)
}

// FetchByTokenCalls gets all the calls that were made to FetchByToken.
// Check the length with:
//     len(mockedStore.FetchByTokenCalls())
func (mock *StoreMock) FetchByTokenCalls() []struct {
	Ctx context.Context
	Tok string
} {
	var calls []struct {
		Ctx context.Context
		Tok string
	}
	lockStoreMockFetchByToken.RLock()
	calls = mock.calls.FetchByToken
	lockStoreMockFetchByToken.RUnlock()
	return calls
}

// FetchByUserKey calls FetchByUserKeyFunc.
func (mock *StoreMock) FetchByUserKey(ctx context.Context, key string) ([]Session, error) {
	if mock.FetchByUserKeyFunc == nil {
		panic("StoreMock.FetchByUserKeyFunc: method is nil but Store.FetchByUserKey was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	lockStoreMockFetchByUserKey.Lock()
	mock.calls.FetchByUserKey = append(mock.calls.FetchByUserKey, callInfo)
	lockStoreMockFetchByUserKey.Unlock()
	return mock.FetchByUserKeyFunc(ctx, key)
}

// FetchByUserKeyCalls gets all the calls that were made to FetchByUserKey.
// Check the length with:
//     len(mockedStore.FetchByUserKeyCalls())
func (mock *StoreMock) FetchByUserKeyCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	lockStoreMockFetchByUserKey.RLock()
	calls = mock.calls.FetchByUserKey
	lockStoreMockFetchByUserKey.RUnlock()
	return calls
}
